{"version":3,"sources":["pubsub.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\r\n * Copyright (c) 2010,2011,2012,2013,2014 Morgan Roderick http://roderick.dk\r\n * License: MIT - http://mrgnrdrck.mit-license.org\r\n *\r\n * https://github.com/mroderick/PubSubJS\r\n */\r\n\r\n(function (root, factory){\r\n    \r\n\r\n    var PubSub = {};\r\n    root.PubSub = PubSub;\r\n\r\n    var define = root.define;\r\n\r\n    factory(PubSub);\r\n\r\n    // AMD support\r\n    if (typeof define === 'function' && define.amd){\r\n        define(function() { return PubSub; });\r\n\r\n        // CommonJS and Node.js module support\r\n    } else if (typeof exports === 'object'){\r\n        if (module !== undefined && module.exports) {\r\n            exports = module.exports = PubSub; // Node.js specific `module.exports`\r\n        }\r\n        exports.PubSub = PubSub; // CommonJS module 1.1.1 spec\r\n        module.exports = exports = PubSub; // CommonJS\r\n    }\r\n\r\n}(( typeof window === 'object' && window ) || this, function (PubSub){\r\n    \r\n\r\n    var messages = {},\r\n        lastUid = -1,\r\n        ALL_SUBSCRIBING_MSG = '*';\r\n\r\n    function hasKeys(obj){\r\n        var key;\r\n\r\n        for (key in obj){\r\n            if ( obj.hasOwnProperty(key) ){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns a function that throws the passed exception, for use as argument for setTimeout\r\n     * @alias throwException\r\n     * @function\r\n     * @param { Object } ex An Error object\r\n     */\r\n    function throwException( ex ){\r\n        return function reThrowException(){\r\n            throw ex;\r\n        };\r\n    }\r\n\r\n    function callSubscriberWithDelayedExceptions( subscriber, message, data ){\r\n        try {\r\n            subscriber( message, data );\r\n        } catch( ex ){\r\n            setTimeout( throwException( ex ), 0);\r\n        }\r\n    }\r\n\r\n    function callSubscriberWithImmediateExceptions( subscriber, message, data ){\r\n        subscriber( message, data );\r\n    }\r\n\r\n    function deliverMessage( originalMessage, matchedMessage, data, immediateExceptions ){\r\n        var subscribers = messages[matchedMessage],\r\n            callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions,\r\n            s;\r\n\r\n        if ( !messages.hasOwnProperty( matchedMessage ) ) {\r\n            return;\r\n        }\r\n\r\n        for (s in subscribers){\r\n            if ( subscribers.hasOwnProperty(s)){\r\n                callSubscriber( subscribers[s], originalMessage, data );\r\n            }\r\n        }\r\n    }\r\n\r\n    function createDeliveryFunction( message, data, immediateExceptions ){\r\n        return function deliverNamespaced(){\r\n            var topic = String( message ),\r\n                position = topic.lastIndexOf( '.' );\r\n\r\n            // deliver the message as it is now\r\n            deliverMessage(message, message, data, immediateExceptions);\r\n\r\n            // trim the hierarchy and deliver message to each level\r\n            while( position !== -1 ){\r\n                topic = topic.substr( 0, position );\r\n                position = topic.lastIndexOf('.');\r\n                deliverMessage( message, topic, data, immediateExceptions );\r\n            }\r\n\r\n            deliverMessage(message, ALL_SUBSCRIBING_MSG, data, immediateExceptions);\r\n        };\r\n    }\r\n\r\n    function hasDirectSubscribersFor( message ) {\r\n        var topic = String( message ),\r\n            found = Boolean(messages.hasOwnProperty( topic ) && hasKeys(messages[topic]));\r\n\r\n        return found;\r\n    }\r\n\r\n    function messageHasSubscribers( message ){\r\n        var topic = String( message ),\r\n            found = hasDirectSubscribersFor(topic) || hasDirectSubscribersFor(ALL_SUBSCRIBING_MSG),\r\n            position = topic.lastIndexOf( '.' );\r\n\r\n        while ( !found && position !== -1 ){\r\n            topic = topic.substr( 0, position );\r\n            position = topic.lastIndexOf( '.' );\r\n            found = hasDirectSubscribersFor(topic);\r\n        }\r\n\r\n        return found;\r\n    }\r\n\r\n    function publish( message, data, sync, immediateExceptions ){\r\n        message = (typeof message === 'symbol') ? message.toString() : message;\r\n\r\n        var deliver = createDeliveryFunction( message, data, immediateExceptions ),\r\n            hasSubscribers = messageHasSubscribers( message );\r\n\r\n        if ( !hasSubscribers ){\r\n            return false;\r\n        }\r\n\r\n        if ( sync === true ){\r\n            deliver();\r\n        } else {\r\n            setTimeout( deliver, 0 );\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Publishes the message, passing the data to it's subscribers\r\n     * @function\r\n     * @alias publish\r\n     * @param { String } message The message to publish\r\n     * @param {} data The data to pass to subscribers\r\n     * @return { Boolean }\r\n     */\r\n    PubSub.publish = function( message, data ){\r\n        return publish( message, data, false, PubSub.immediateExceptions );\r\n    };\r\n\r\n    /**\r\n     * Publishes the message synchronously, passing the data to it's subscribers\r\n     * @function\r\n     * @alias publishSync\r\n     * @param { String } message The message to publish\r\n     * @param {} data The data to pass to subscribers\r\n     * @return { Boolean }\r\n     */\r\n    PubSub.publishSync = function( message, data ){\r\n        return publish( message, data, true, PubSub.immediateExceptions );\r\n    };\r\n\r\n    /**\r\n     * Subscribes the passed function to the passed message. Every returned token is unique and should be stored if you need to unsubscribe\r\n     * @function\r\n     * @alias subscribe\r\n     * @param { String } message The message to subscribe to\r\n     * @param { Function } func The function to call when a new message is published\r\n     * @return { String }\r\n     */\r\n    PubSub.subscribe = function( message, func ){\r\n        if ( typeof func !== 'function'){\r\n            return false;\r\n        }\r\n\r\n        message = (typeof message === 'symbol') ? message.toString() : message;\r\n\r\n        // message is not registered yet\r\n        if ( !messages.hasOwnProperty( message ) ){\r\n            messages[message] = {};\r\n        }\r\n\r\n        // forcing token as String, to allow for future expansions without breaking usage\r\n        // and allow for easy use as key names for the 'messages' object\r\n        var token = 'uid_' + String(++lastUid);\r\n        messages[message][token] = func;\r\n        \r\n        // return token for unsubscribing\r\n        return token;\r\n    };\r\n\r\n    PubSub.subscribeAll = function( func ){\r\n        return PubSub.subscribe(ALL_SUBSCRIBING_MSG, func);\r\n    };\r\n\r\n    /**\r\n     * Subscribes the passed function to the passed message once\r\n     * @function\r\n     * @alias subscribeOnce\r\n     * @param { String } message The message to subscribe to\r\n     * @param { Function } func The function to call when a new message is published\r\n     * @return { PubSub }\r\n     */\r\n    PubSub.subscribeOnce = function( message, func ){\r\n        var token = PubSub.subscribe( message, function(){\r\n            // before func apply, unsubscribe message\r\n            PubSub.unsubscribe( token );\r\n            func.apply( this, arguments );\r\n        });\r\n        return PubSub;\r\n    };\r\n\r\n    /**\r\n     * Clears all subscriptions\r\n     * @function\r\n     * @public\r\n     * @alias clearAllSubscriptions\r\n     */\r\n    PubSub.clearAllSubscriptions = function clearAllSubscriptions(){\r\n        messages = {};\r\n    };\r\n\r\n    /**\r\n     * Clear subscriptions by the topic\r\n     * @function\r\n     * @public\r\n     * @alias clearAllSubscriptions\r\n     * @return { int }\r\n     */\r\n    PubSub.clearSubscriptions = function clearSubscriptions(topic){\r\n        var m;\r\n        for (m in messages){\r\n            if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0){\r\n                delete messages[m];\r\n            }\r\n        }\r\n    };\r\n\r\n    /** \r\n       Count subscriptions by the topic\r\n     * @function\r\n     * @public\r\n     * @alias countSubscriptions\r\n     * @return { Array }\r\n    */\r\n    PubSub.countSubscriptions = function countSubscriptions(topic){\r\n        var m;\r\n        var count = 0;\r\n        for (m in messages){\r\n            if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0){\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    };\r\n\r\n    \r\n    /** \r\n       Gets subscriptions by the topic\r\n     * @function\r\n     * @public\r\n     * @alias getSubscriptions\r\n    */\r\n    PubSub.getSubscriptions = function getSubscriptions(topic){\r\n        var m;\r\n        var list = [];\r\n        for (m in messages){\r\n            if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0){\r\n                list.push(m);\r\n            }\r\n        }\r\n        return list;\r\n    };\r\n\r\n    /**\r\n     * Removes subscriptions\r\n     *\r\n     * - When passed a token, removes a specific subscription.\r\n     *\r\n\t * - When passed a function, removes all subscriptions for that function\r\n     *\r\n\t * - When passed a topic, removes all subscriptions for that topic (hierarchy)\r\n     * @function\r\n     * @public\r\n     * @alias subscribeOnce\r\n     * @param { String | Function } value A token, function or topic to unsubscribe from\r\n     * @example // Unsubscribing with a token\r\n     * var token = PubSub.subscribe('mytopic', myFunc);\r\n     * PubSub.unsubscribe(token);\r\n     * @example // Unsubscribing with a function\r\n     * PubSub.unsubscribe(myFunc);\r\n     * @example // Unsubscribing from a topic\r\n     * PubSub.unsubscribe('mytopic');\r\n     */\r\n    PubSub.unsubscribe = function(value){\r\n        var descendantTopicExists = function(topic) {\r\n                var m;\r\n                for ( m in messages ){\r\n                    if ( messages.hasOwnProperty(m) && m.indexOf(topic) === 0 ){\r\n                        // a descendant of the topic exists:\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            },\r\n            isTopic    = typeof value === 'string' && ( messages.hasOwnProperty(value) || descendantTopicExists(value) ),\r\n            isToken    = !isTopic && typeof value === 'string',\r\n            isFunction = typeof value === 'function',\r\n            result = false,\r\n            m, message, t;\r\n\r\n        if (isTopic){\r\n            PubSub.clearSubscriptions(value);\r\n            return;\r\n        }\r\n\r\n        for ( m in messages ){\r\n            if ( messages.hasOwnProperty( m ) ){\r\n                message = messages[m];\r\n\r\n                if ( isToken && message[value] ){\r\n                    delete message[value];\r\n                    result = value;\r\n                    // tokens are unique, so we can just stop here\r\n                    break;\r\n                }\r\n\r\n                if (isFunction) {\r\n                    for ( t in message ){\r\n                        if (message.hasOwnProperty(t) && message[t] === value){\r\n                            delete message[t];\r\n                            result = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n}));\r\n"]}